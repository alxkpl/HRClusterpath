[{"path":"https://alxkpl.github.io/HRClusterpath/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alexandre CAPEL. Author, maintainer.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"CAPEL (2025). HRClusterpath: Clusterpath Hüsler-Reiss. R package version 0.1.0, https://alxkpl.github.io/HRClusterpath/.","code":"@Manual{,   title = {HRClusterpath: Clusterpath for Hüsler-Reiss},   author = {Alexandre CAPEL},   year = {2025},   note = {R package version 0.1.0},   url = {https://alxkpl.github.io/HRClusterpath/}, }"},{"path":"https://alxkpl.github.io/HRClusterpath/index.html","id":"hrclusterpath","dir":"","previous_headings":"","what":"Clusterpath for Hüsler-Reiss","title":"Clusterpath for Hüsler-Reiss","text":"HRClusterpath R-package provides tools variable clustering Husler-Reiss models, specially using graphical models structure.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Clusterpath for Hüsler-Reiss","text":"install package, one can write R-terminal :","code":"remotes::install_github(\"alxkpl/HRClusterpath\")"},{"path":"https://alxkpl.github.io/HRClusterpath/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Clusterpath for Hüsler-Reiss","text":"section gives overview package’s tools.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/index.html","id":"clusterpath-algorithm-for-hierarchical-clustering","dir":"","previous_headings":"Usage","what":"Clusterpath algorithm for hierarchical clustering","title":"Clusterpath for Hüsler-Reiss","text":"first method can use package hierarchical clustering (variables) using Clusterpath algorithm applied likelihood precision matrix Husler Reiss graphical model fused-Lasso penalty. can use : get_cluster get optimal cluster fixed parameter \\(\\lambda\\) estimated variogram \\(\\hat \\Gamma\\) customizable weights. HR_Clusterpath build list optimal results grid \\(\\lambda\\) standards exponnential weights. gg_cluster provides dendrogram induced results HR_Clusterpath function. others functions analyze results.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/ChiToGamma.html","id":null,"dir":"Reference","previous_headings":"","what":"ChiToGamma — ChiToGamma","title":"ChiToGamma — ChiToGamma","text":"Transform \\(\\chi\\) matrix corresponding variogram \\(\\Gamma\\)","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/ChiToGamma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"ChiToGamma — ChiToGamma","text":"","code":"ChiToGamma(Chi_matrix)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/ChiToGamma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"ChiToGamma — ChiToGamma","text":"Chi_matrix matrix \\(\\chi_{ij}\\) entries.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/ChiToGamma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"ChiToGamma — ChiToGamma","text":"Gives variogram \\(\\Gamma\\) according \\(\\chi\\) matrix Hüsler-Reiss MGDP. case, exists closed equation link variogram extremal coefficients, given : $$    \\chi_{ij} = 2 - 2 \\phi(\\sqrt{\\Gamma_{ij}/2}) $$ \\(\\phi\\) standard normal distribution function.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/ChiToGamma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"ChiToGamma — ChiToGamma","text":"","code":"ChiToGamma(matrix(c(1, 0.7,                     0.7, 1),            nrow = 2)) #>           [,1]      [,2] #> [1,] 0.0000000 0.5938874 #> [2,] 0.5938874 0.0000000"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/D_tilde2_r.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster distance squared function — D_tilde2_r","title":"Cluster distance squared function — D_tilde2_r","text":"Cluster distance squared function","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/D_tilde2_r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster distance squared function — D_tilde2_r","text":"","code":"D_tilde2_r(R, clusters)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/D_tilde2_r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster distance squared function — D_tilde2_r","text":"R K x K symmetric matrix. clusters list vector : vector gives element cluster.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/D_tilde2_r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster distance squared function — D_tilde2_r","text":"function cluster number : compute square distance two clusters distance defined section 4.2 cluster document.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/D_tilde2_r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster distance squared function — D_tilde2_r","text":"","code":"R <- matrix(c(0.5, -1,               -1, -1), nr = 2) clusters <- list(c(1,3), c(2,4)) D2 <- D_tilde2_r(R, clusters) #> Error in D_tilde2_r(R, clusters): could not find function \"D_tilde2_r\" D2(1, 2) #> Error in D2(1, 2): could not find function \"D2\""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/U_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Computation of the matrix of clusters — U_matrix","title":"Computation of the matrix of clusters — U_matrix","text":"Computation matrix clusters","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/U_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computation of the matrix of clusters — U_matrix","text":"","code":"U_matrix(clusters)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/U_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computation of the matrix of clusters — U_matrix","text":"clusters list vector : vector gives element cluster.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/U_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computation of the matrix of clusters — U_matrix","text":"d x K matrix U u_jk = 1 variable j belongs cluster C_k 0 otherwise.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/U_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computation of the matrix of clusters — U_matrix","text":"","code":"clusters <- list(c(1,2,3),c(4,5)) U_matrix(clusters) #> Error in U_matrix(clusters): could not find function \"U_matrix\""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/compare_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare two clusters. — compare_clusters","title":"Compare two clusters. — compare_clusters","text":"Compare two clusters.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/compare_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare two clusters. — compare_clusters","text":"","code":"compare_clusters(clusters1, clusters2)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/compare_clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare two clusters. — compare_clusters","text":"clusters1 first cluster compare. clusters2 second cluster compare.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/compare_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare two clusters. — compare_clusters","text":"Return FALSE clusters number cluster. Otherwise,","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/compute_W.html","id":null,"dir":"Reference","previous_headings":"","what":"Computation of the first weight matrix — compute_W","title":"Computation of the first weight matrix — compute_W","text":"Computation first weight matrix","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/compute_W.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computation of the first weight matrix — compute_W","text":"","code":"compute_W(data)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/compute_W.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computation of the first weight matrix — compute_W","text":"data data","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/compute_W.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computation of the first weight matrix — compute_W","text":"initial wieght matrix without fused variables.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/crout_factorisation.html","id":null,"dir":"Reference","previous_headings":"","what":"Crout factorization algorithm. — crout_factorisation","title":"Crout factorization algorithm. — crout_factorisation","text":"Crout factorization algorithm.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/crout_factorisation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Crout factorization algorithm. — crout_factorisation","text":"","code":"crout_factorisation(A, tol = 1e-12)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/crout_factorisation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Crout factorization algorithm. — crout_factorisation","text":"d x d symmetric positive matrix. tol positive value : tolerance zero diagonal","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/crout_factorisation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Crout factorization algorithm. — crout_factorisation","text":"LU Crout decomposition matrix . symmetric positive matrix, exists LU decomposition : = L' L","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/crout_factorisation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Crout factorization algorithm. — crout_factorisation","text":"","code":"A <- matrix(c(1,2,3,              2,5,6,              3,6,9), nc = 3) L <- crout_factorisation(A) #> Error in crout_factorisation(A): could not find function \"crout_factorisation\" L %*% t(L) #> Error: object 'L' not found"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/detect_merge.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect the merge and give all information about cluster and lambda. — detect_merge","title":"Detect the merge and give all information about cluster and lambda. — detect_merge","text":"Detect merge give information cluster lambda.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/detect_merge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect the merge and give all information about cluster and lambda. — detect_merge","text":"","code":"detect_merge(solution_list)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/detect_merge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect the merge and give all information about cluster and lambda. — detect_merge","text":"solution_list Solution's list best_clusters.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/detect_merge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect the merge and give all information about cluster and lambda. — detect_merge","text":"Return list solution change occurs list clusters.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gamma_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Variogram transformation application gamma — gamma_function","title":"Variogram transformation application gamma — gamma_function","text":"Variogram transformation application gamma","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gamma_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variogram transformation application gamma — gamma_function","text":"","code":"gamma_function(sigma)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gamma_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variogram transformation application gamma — gamma_function","text":"sigma d x d numeric matrix.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gamma_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variogram transformation application gamma — gamma_function","text":"symmetric positive matrix sigma (covariance matrix), return corresponding variogram matrix. Can used interpretation.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gamma_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variogram transformation application gamma — gamma_function","text":"","code":"s_sigma <- matrix(rnorm(16, 2), nc = 4) gamma_function(s_sigma %*% t(s_sigma)) #> Error in gamma_function(s_sigma %*% t(s_sigma)): could not find function \"gamma_function\""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gen_det.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalised determinant — gen_det","title":"Generalised determinant — gen_det","text":"Generalised determinant","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gen_det.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalised determinant — gen_det","text":"","code":"gen_det(A, tol = 1e-10)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gen_det.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalised determinant — gen_det","text":"d x d real valued matrix. tol positive value.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gen_det.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalised determinant — gen_det","text":"Compute generalised determinant matrix . recall generalised determinant extension determinant singular matrix. corresponds product non zero eigen values.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gen_det.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalised determinant — gen_det","text":"","code":"A <- matrix(c(1,2,3,               2,5,6,               3,6,9), nc = 3) gen_det(A) #> Error in gen_det(A): could not find function \"gen_det\""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/get_adjacency_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Give the adjacency matrix coresponding to the right hierarchical according to the fusion during optimization. — get_adjacency_matrix","title":"Give the adjacency matrix coresponding to the right hierarchical according to the fusion during optimization. — get_adjacency_matrix","text":"Give adjacency matrix coresponding right hierarchical according fusion optimization.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/get_adjacency_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Give the adjacency matrix coresponding to the right hierarchical according to the fusion during optimization. — get_adjacency_matrix","text":"","code":"get_adjacency_matrix(event_list, lambda_max)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/get_adjacency_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Give the adjacency matrix coresponding to the right hierarchical according to the fusion during optimization. — get_adjacency_matrix","text":"event_list list solution detect_fusion. lambda_max lambda end optimization.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/get_adjacency_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Give the adjacency matrix coresponding to the right hierarchical according to the fusion during optimization. — get_adjacency_matrix","text":"matrix use construction dendrogram.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gradient_D2.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient matrix of distance between two columns — gradient_D2","title":"Gradient matrix of distance between two columns — gradient_D2","text":"Gradient matrix distance two columns","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gradient_D2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient matrix of distance between two columns — gradient_D2","text":"","code":"gradient_D2(R, clusters)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gradient_D2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient matrix of distance between two columns — gradient_D2","text":"R K x K symmetric matrix. clusters list vector : vector gives element cluster.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gradient_D2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient matrix of distance between two columns — gradient_D2","text":"Return functon indices (k', l') computing gradient matrix tilde D^2(r_k', r_l'). See section 4.3.3 cluster document details.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/gradient_D2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient matrix of distance between two columns — gradient_D2","text":"","code":"R <- matrix(c(-1,0,-2,               0,-3,-1,               -2,-1,-1), 3) clusters <- list(c(1,3), c(2), 4) grad <- gradient_D2(R, clusters) #> Error in gradient_D2(R, clusters): could not find function \"gradient_D2\" grad(1, 2) #> Error in grad(1, 2): could not find function \"grad\""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hierarchy-graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Clusterpath as hierarchical clustering — hierarchy-graph","title":"Clusterpath as hierarchical clustering — hierarchy-graph","text":"ggplot2 ggraph function plotting results clusterpath algorithm.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hierarchy-graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clusterpath as hierarchical clustering — hierarchy-graph","text":"","code":"gg_cluster(list_results, id_names = NULL)  average_hierarchy(replicates)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hierarchy-graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clusterpath as hierarchical clustering — hierarchy-graph","text":"list_results list results optimization HR_Clusterpath(). id_names liste strings nodes label. NULL (default), labels integer \\(1\\) \\(d\\), number variables. replicates list results optimization replicates HR_Clusterpath().","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hierarchy-graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clusterpath as hierarchical clustering — hierarchy-graph","text":"gg_cluster(), dendrogram obtained optimization results HR_Clusterpath() lambda. average_hierarchy(), average dendrogram obtained several optimization results HR_Clusterpath() lambda.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hierarchy-graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clusterpath as hierarchical clustering — hierarchy-graph","text":"development \\([1]\\), clusterpath algorithm built convex relaxation hierarchical clustering allows us produce kind graphs results algorithm enough thin large grid penalty \\(\\lambda\\).","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hierarchy-graph.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Clusterpath as hierarchical clustering — hierarchy-graph","text":"\\([1]\\) Hocking, T. D., Joulin, ., Bach, F., Vert, J.-P. (2011). Clusterpath: Algorithm Clustering using Convex Fusion Penalties. Proceedings 28th International Conference Machine Learning, Bellevue, Washington, USA,. Omnipress.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hierarchy-graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clusterpath as hierarchical clustering — hierarchy-graph","text":"","code":"# Construction of clusters and R matrix R <- matrix(c(1, -3, 0,               -3, 2, -2,               0, -2, 1), nc = 3) clusters <- list(1:5, 6:10, 11:15)  # Construction of induced theta and corresponding variogram gamma Theta <- build_theta(R, clusters) Gamma <- graphicalExtremes::Theta2Gamma(Theta)  gr3_bal_sim_param_cluster <-   list(     R = R,     clusters = clusters,     Theta = Theta,     Gamma = Gamma,     chi = 1,     n = 1e3,     d = 15   )  set.seed(804) data <- graphicalExtremes::rmpareto(n = gr3_bal_sim_param_cluster$n,                                     model = \"HR\",                                     par = gr3_bal_sim_param_cluster$Gamma)  lambda <- seq(0, 3, 1e-3)  res <- HR_Clusterpath(data = data,                       zeta = gr3_bal_sim_param_cluster$chi,                       lambda = lambda,                       eps_f = 1e-1)  gg_cluster(res)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hr-clusterpath.html","id":null,"dir":"Reference","previous_headings":"","what":"Clusterpath algorithm for Hüsler-Reiss models — hr-clusterpath","title":"Clusterpath algorithm for Hüsler-Reiss models — hr-clusterpath","text":"Gradient descent based Clusterpath algorithm adapted likelihood graphical Hüsler-Reiss model. Usefull precision matrix \\(\\Theta\\) (variogram \\(\\Gamma\\)) block matrix structure.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hr-clusterpath.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clusterpath algorithm for Hüsler-Reiss models — hr-clusterpath","text":"","code":"get_cluster(gamma, weights, eps_f, ...)  HR_Clusterpath(   data,   zeta,   lambda,   p = NULL,   eps_g = 0.001,   eps_f = 0.01,   it_max = 1000 )"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hr-clusterpath.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clusterpath algorithm for Hüsler-Reiss models — hr-clusterpath","text":"gamma get_clusters(), \\(d \\times d\\) matrix : variogram matrix \\(\\Gamma\\). weights get_clusters(), \\(d \\times d\\) symmetric weightsmatrix zero diagonal. eps_f positive number : tolerance threshold merging clusters. data HR_Clusterapth(), \\(n \\times d\\) matrix : matrix data. zeta HR_Clusterapth(), positive number : tuned parameter exponential weights. lambda get_clusters(), positive number : weight penalty. HR_Clusterpath(), numerix vector positive number : grid line \\(\\lambda\\). p HR_Clusterapth(), numeric 0 1, NULL.  NULL (default), assumed data already multivariate Pareto scale. Else, p used probability function data2mpareto() standardize data (see graphicalExtremes documentation). eps_g positive number : tolerance threshold convergence gradient descent. it_max integer : maximal number iteration gradient descent algorithm.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hr-clusterpath.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clusterpath algorithm for Hüsler-Reiss models — hr-clusterpath","text":"HR_Clusterpath() gradient descent data default values method optimization : variogram matrix \\(\\Gamma\\) empirical variogram weights set exponential weights, depends one tuning parameter \\(\\zeta\\) theoretical results. get_clusters() freer version previous function. can use estimation variogram \\(\\Gamma\\) customizable weights matrix \\(W\\). produce list results : $R : \\(R\\) matrix clusters. $clusters : list variable indices, clustered. $nllh : value negative penalised negative loglikelihood. $lambda : value lambda. $message : message optimization results. case HR_Clusterpath() list previous list.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hr-clusterpath.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clusterpath algorithm for Hüsler-Reiss models — hr-clusterpath","text":"block matrix models defined two elements : cluster's partition \\(\\{C_1, \\dots, C_K\\}\\), included \\(V\\) \\(R\\) matrix belongs \\(\\mathcal S_K(\\mathbb R)\\), set symmetric \\(K \\times K\\) matrix (See also build_theta() extract_R_matrix()). Clusterpath aims find optimum penalised negative loglikelihood defined neg_likelihood_pen().","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hr-clusterpath.html","id":"some-results-for-hr-clusterpath-","dir":"Reference","previous_headings":"","what":"Some results for HR_Clusterpath()","title":"Clusterpath algorithm for Hüsler-Reiss models — hr-clusterpath","text":"get replications \\(X_1, \\dots, X_n\\) random vector \\(X\\) belongs attraction domain \\(K\\)-block Hüsler-Reiss graphical model, minimum penalised negative loglikelihood conveges almost surely true precision matrix model \\(\\Theta^*\\), \\(\\lambda\\), provided choose sequence \\((\\zeta_n)_{n\\\\mathbb N^*}\\) grows slower \\(log(n)\\) sequence. general, \\(\\zeta \\[1,2]\\) good choice.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/hr-clusterpath.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clusterpath algorithm for Hüsler-Reiss models — hr-clusterpath","text":"","code":"############################################################################ #                            With get_clusters ############################################################################ # Customizable weights W <- matrix(c(0, 1, 1, 1,               1, 0, 1, 1,               1, 1, 0, 1,               1, 1, 1, 0), nc = 4)  # Free choice of variogram gamma <- graphicalExtremes::generate_random_Gamma(d = 4)  # Choice of initial condition for the optimization R <- matrix(c(1, 0, 0, -1,               0, 1, 1, -2,               0, 1, 1, -1,               -1, -2, -1, 1), nc = 4) lambda <- 2.2  Cluster_HR <- get_cluster(gamma, W, 100)  Cluster_HR(R, 2.2) #> Error in U %*% R: non-conformable arguments  ############################################################################ #                            With HR_Clusterpath ############################################################################ # Construction of clusters and R matrix for simulation R <- matrix(c(1, -3, 0,               -3, 2, -2,               0, -2, 1), nc = 3) clusters <- list(1:5, 6:10, 11:15)  # Construction of induced theta and corresponding variogram gamma Theta <- build_theta(R, clusters) Gamma <- graphicalExtremes::Theta2Gamma(Theta)  gr3_bal_sim_param_cluster <-   list(     R = R,     clusters = clusters,     Theta = Theta,     Gamma = Gamma,     chi = 1,     n = 1e3,     d = 15   )  # Simulation of the data set.seed(804) data <- graphicalExtremes::rmpareto(n = gr3_bal_sim_param_cluster$n,                                     model = \"HR\",                                     par = gr3_bal_sim_param_cluster$Gamma)  # Optimization with Clusterpath algorithm with empirical variogram and exponential weights lambda <- c(0, 0.1, 0.5, 1, 2)  HR_Clusterpath(data = data,                zeta = gr3_bal_sim_param_cluster$chi,                lambda = lambda,                eps_f = 1e-1) #> [[1]] #> [[1]]$R #>              [,1]        [,2]        [,3]        [,4]        [,5]      [,6] #>  [1,] 11.62569700  0.67369437  0.14917425  0.79782350  0.81549832 -2.792292 #>  [2,]  0.67369437 10.53787951  1.05168936  1.42552262  1.30727908 -2.422037 #>  [3,]  0.14917425  1.05168936 11.22827891  1.43595090  0.79434028 -3.261501 #>  [4,]  0.79782350  1.42552262  1.43595090 11.32735995  0.88472654 -2.812041 #>  [5,]  0.81549832  1.30727908  0.79434028  0.88472654 10.20111555 -3.095132 #>  [6,] -2.79229153 -2.42203669 -3.26150083 -2.81204104 -3.09513159 17.386299 #>  [7,] -3.46255518 -2.91051426 -3.18341446 -3.42025788 -2.18772269  1.519077 #>  [8,] -2.06212105 -3.43386045 -2.28495826 -1.95434999 -3.35961874  1.361253 #>  [9,] -3.58274945 -2.74227664 -2.63255032 -2.93335439 -2.43851909  1.914010 #> [10,] -1.89746317 -2.32967878 -3.03570771 -3.88542699 -2.68035986  1.838097 #> [11,] -0.23128024 -0.62256783 -0.10789576 -0.61237958  0.02556595 -2.255061 #> [12,] -0.04118799 -0.28309068 -0.03209155  0.02202898 -0.08742993 -1.676326 #> [13,] -0.27531206  0.07202651  0.43777054 -0.11127959 -0.06601219 -1.981196 #> [14,] -0.15728786 -0.04916659 -0.42175823  0.18720272  0.20268767 -1.799423 #> [15,]  0.44036110 -0.27489952 -0.13732712 -0.35152576 -0.31641930 -1.923729 #>             [,7]       [,8]      [,9]     [,10]       [,11]       [,12] #>  [1,] -3.4625552 -2.0621211 -3.582749 -1.897463 -0.23128024 -0.04118799 #>  [2,] -2.9105143 -3.4338605 -2.742277 -2.329679 -0.62256783 -0.28309068 #>  [3,] -3.1834145 -2.2849583 -2.632550 -3.035708 -0.10789576 -0.03209155 #>  [4,] -3.4202579 -1.9543500 -2.933354 -3.885427 -0.61237958  0.02202898 #>  [5,] -2.1877227 -3.3596187 -2.438519 -2.680360  0.02556595 -0.08742993 #>  [6,]  1.5190774  1.3612527  1.914010  1.838097 -2.25506097 -1.67632609 #>  [7,] 17.8097863  0.9736359  2.177892  1.908403 -1.23845305 -2.33417631 #>  [8,]  0.9736359 16.8615867  1.378395  1.442956 -1.47371448 -2.21745767 #>  [9,]  2.1778924  1.3783949 17.162554  1.861684 -1.88155578 -2.11439936 #> [10,]  1.9084033  1.4429559  1.861684 16.661355 -1.85037578 -2.46393406 #> [11,] -1.2384531 -1.4737145 -1.881556 -1.850376  6.12434446  1.25874961 #> [12,] -2.3341763 -2.2174577 -2.114399 -2.463934  1.25874961  6.55382058 #> [13,] -1.5962204 -1.8417352 -2.249246 -1.825178  0.84281588  0.83285285 #> [14,] -2.0294652 -1.7612351 -2.047525 -1.703477  0.78110014  1.22367932 #> [15,] -2.0260159 -1.6287752 -1.872359 -2.040894  1.24070742  1.35896229 #>             [,13]       [,14]      [,15] #>  [1,] -0.27531206 -0.15728786  0.4403611 #>  [2,]  0.07202651 -0.04916659 -0.2748995 #>  [3,]  0.43777054 -0.42175823 -0.1373271 #>  [4,] -0.11127959  0.18720272 -0.3515258 #>  [5,] -0.06601219  0.20268767 -0.3164193 #>  [6,] -1.98119607 -1.79942282 -1.9237286 #>  [7,] -1.59622037 -2.02946515 -2.0260159 #>  [8,] -1.84173523 -1.76123511 -1.6287752 #>  [9,] -2.24924619 -2.04752523 -1.8723595 #> [10,] -1.82517818 -1.70347677 -2.0408942 #> [11,]  0.84281588  0.78110014  1.2407074 #> [12,]  0.83285285  1.22367932  1.3589623 #> [13,]  6.13662851  0.91971361  0.7043720 #> [14,]  0.91971361  5.90209604  0.7528583 #> [15,]  0.70437198  0.75285827  6.0746840 #>  #> [[1]]$clusters #> [[1]]$clusters[[1]] #> [1] 1 #>  #> [[1]]$clusters[[2]] #> [1] 2 #>  #> [[1]]$clusters[[3]] #> [1] 3 #>  #> [[1]]$clusters[[4]] #> [1] 4 #>  #> [[1]]$clusters[[5]] #> [1] 5 #>  #> [[1]]$clusters[[6]] #> [1] 6 #>  #> [[1]]$clusters[[7]] #> [1] 7 #>  #> [[1]]$clusters[[8]] #> [1] 8 #>  #> [[1]]$clusters[[9]] #> [1] 9 #>  #> [[1]]$clusters[[10]] #> [1] 10 #>  #> [[1]]$clusters[[11]] #> [1] 11 #>  #> [[1]]$clusters[[12]] #> [1] 12 #>  #> [[1]]$clusters[[13]] #> [1] 13 #>  #> [[1]]$clusters[[14]] #> [1] 14 #>  #> [[1]]$clusters[[15]] #> [1] 15 #>  #>  #> [[1]]$nllh #> [1] -18.74698 #>  #> [[1]]$lambda #> [1] 0 #>  #> [[1]]$message #> [1] \"Initial guess for null lambda.\" #>  #>  #> [[2]] #> [[2]]$R #>              [,1]       [,2]        [,3]       [,4]      [,5]      [,6] #>  [1,] 11.62569700  0.7457596  0.40203639  0.7394198 -2.891927 -3.196674 #>  [2,]  0.74575960  1.2600307  0.99832528  1.1216766 -2.726927 -2.667609 #>  [3,]  0.40203639  0.9983253 11.22827891  1.3281153 -3.012906 -2.963637 #>  [4,]  0.73941985  1.1216766  1.32811532 11.3273600 -3.016338 -3.059981 #>  [5,] -2.89192673 -2.7269266 -3.01290630 -3.0163376 17.386299  1.824530 #>  [6,] -3.19667448 -2.6676091 -2.96363725 -3.0599811  1.824530  1.988305 #>  [7,] -2.14802383 -3.2150179 -2.39972033 -2.1145902  1.334903  1.263783 #>  [8,] -2.27285771 -2.6083130 -3.01611967 -3.4560025  1.844892  1.872678 #>  [9,] -0.06893046 -0.1067248 -0.09171188 -0.1404846 -1.931374 -1.931758 #>            [,7]      [,8]        [,9] #>  [1,] -2.148024 -2.272858 -0.06893046 #>  [2,] -3.215018 -2.608313 -0.10672483 #>  [3,] -2.399720 -3.016120 -0.09171188 #>  [4,] -2.114590 -3.456002 -0.14048459 #>  [5,]  1.334903  1.844892 -1.93137369 #>  [6,]  1.263783  1.872678 -1.93175793 #>  [7,] 16.861587  1.426461 -1.78302008 #>  [8,]  1.426461 16.661355 -1.92776632 #>  [9,] -1.783020 -1.927766  0.99906912 #>  #> [[2]]$clusters #> [[2]]$clusters[[1]] #> [1] 1 #>  #> [[2]]$clusters[[2]] #> [1] 2 5 #>  #> [[2]]$clusters[[3]] #> [1] 3 #>  #> [[2]]$clusters[[4]] #> [1] 4 #>  #> [[2]]$clusters[[5]] #> [1] 6 #>  #> [[2]]$clusters[[6]] #> [1] 7 9 #>  #> [[2]]$clusters[[7]] #> [1] 8 #>  #> [[2]]$clusters[[8]] #> [1] 10 #>  #> [[2]]$clusters[[9]] #> [1] 11 12 13 14 15 #>  #>  #> [[2]]$nllh #> [1] -18.6258 #>  #> [[2]]$lambda #> [1] 0.1 #>  #> [[2]]$message #> NULL #>  #>  #> [[3]] #> [[3]]$R #>            [,1]       [,2]       [,3]      [,4]      [,5]       [,6] #> [1,] 11.6256970  0.8385883  0.7209617 -2.870505 -2.379425 -0.1184871 #> [2,]  0.8385883  1.2068774  1.0353637 -2.778825 -2.825443 -0.1034719 #> [3,]  0.7209617  1.0353637  1.0749056 -2.880245 -2.564407 -0.1325878 #> [4,] -2.8705052 -2.7788255 -2.8802455  1.762949  1.445556 -1.9056921 #> [5,] -2.3794245 -2.8254432 -2.5644066  1.445556 16.861587 -1.8442872 #> [6,] -0.1184871 -0.1034719 -0.1325878 -1.905692 -1.844287  0.9999403 #>  #> [[3]]$clusters #> [[3]]$clusters[[1]] #> [1] 1 #>  #> [[3]]$clusters[[2]] #> [1] 2 5 #>  #> [[3]]$clusters[[3]] #> [1] 3 4 #>  #> [[3]]$clusters[[4]] #> [1]  6  7  9 10 #>  #> [[3]]$clusters[[5]] #> [1] 8 #>  #> [[3]]$clusters[[6]] #> [1] 11 12 13 14 15 #>  #>  #> [[3]]$nllh #> [1] -18.62144 #>  #> [[3]]$lambda #> [1] 0.5 #>  #> [[3]]$message #> NULL #>  #>  #> [[4]] #> [[4]]$R #>            [,1]       [,2]      [,3]      [,4]       [,5] #> [1,] 11.6256970  0.8376860 -2.846009 -2.471630 -0.1356053 #> [2,]  0.8376860  1.0158239 -2.801814 -2.689447 -0.1224851 #> [3,] -2.8460095 -2.8018145  1.706345  1.483118 -1.9023560 #> [4,] -2.4716297 -2.6894469  1.483118 16.861587 -1.8596616 #> [5,] -0.1356053 -0.1224851 -1.902356 -1.859662  0.9894070 #>  #> [[4]]$clusters #> [[4]]$clusters[[1]] #> [1] 1 #>  #> [[4]]$clusters[[2]] #> [1] 2 5 3 4 #>  #> [[4]]$clusters[[3]] #> [1]  6  7  9 10 #>  #> [[4]]$clusters[[4]] #> [1] 8 #>  #> [[4]]$clusters[[5]] #> [1] 11 12 13 14 15 #>  #>  #> [[4]]$nllh #> [1] -18.61705 #>  #> [[4]]$lambda #> [1] 1 #>  #> [[4]]$message #> NULL #>  #>  #> [[5]] #> [[5]]$R #>            [,1]      [,2]       [,3] #> [1,]  0.8905508 -2.739169 -0.1168082 #> [2,] -2.7391691  1.553834 -1.8858920 #> [3,] -0.1168082 -1.885892  0.9843714 #>  #> [[5]]$clusters #> [[5]]$clusters[[1]] #> [1] 1 2 5 3 4 #>  #> [[5]]$clusters[[2]] #> [1]  6  7  9 10  8 #>  #> [[5]]$clusters[[3]] #> [1] 11 12 13 14 15 #>  #>  #> [[5]]$nllh #> [1] -18.62088 #>  #> [[5]]$lambda #> [1] 2 #>  #> [[5]]$message #> NULL #>  #>"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/likelihood.html","id":null,"dir":"Reference","previous_headings":"","what":"Negative log-likelihood for Hüsler-Reiss graphical models — likelihood","title":"Negative log-likelihood for Hüsler-Reiss graphical models — likelihood","text":"penalised negative loglikelihood Hüsler-Reiss graphical models can written follow : $$  L_{\\mathcal P}^{(n)}(\\Theta, \\lambda) = \\underbrace{-\\log(|\\Theta|_+) -  \\frac 12 \\text{tr}(\\hat \\Gamma^{(n)}\\Theta)}_{L^{(n)}(\\Theta)} + \\lambda  \\underbrace{\\sum_{<j} w_{ij} d^2_{ij}(\\Theta)}_{\\mathcal P(\\Theta)} $$ \\(|\\cdot|_+\\) generalised determinant, \\(n\\) sample size, \\(\\hat \\Gamma^{(n)}\\) estimation variogram matrix \\(\\Gamma\\) \\(w_{ij}>0\\) weights.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/likelihood.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Negative log-likelihood for Hüsler-Reiss graphical models — likelihood","text":"","code":"neg_likelihood(gamma)  penalty(weights)  neg_likelihood_pen(gamma, weights)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/likelihood.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Negative log-likelihood for Hüsler-Reiss graphical models — likelihood","text":"gamma \\(d \\times d\\) matrix: variogram matrix \\(\\Gamma\\). weights \\(d \\times d\\) symmetric matrix \\(W\\) zero diagonal.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/likelihood.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Negative log-likelihood for Hüsler-Reiss graphical models — likelihood","text":"neg_likelihood(), produces function two parameters : R \\(K \\times K\\) clusters matrix clusters list indices associated partition \\(V\\) compute value non penalised negative log-likelihood \\(L^{(n)}(\\Theta)\\). penalty(), produces function two parameters : R \\(K \\times K\\) clusters matrix clusters list indices associated partition \\(V\\) compute value penalty \\(\\mathcal P(\\Theta)\\). neg_likelihood_pen(), produces function three parameters : R : \\(K \\times K\\) clusters matrix clusters : list indices associated partition \\(V\\) lambda : positive number, weight penalty. compute value penalised negative log-likelihood \\(L_{\\mathcal P}^{(n)}(\\Theta, \\lambda)\\).","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/likelihood.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Negative log-likelihood for Hüsler-Reiss graphical models — likelihood","text":"use block matrix structure compute likelihood (see build_theta() extract_R_matrix()), use two parameters computation instead one matrix \\(\\Theta\\).","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/likelihood.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Negative log-likelihood for Hüsler-Reiss graphical models — likelihood","text":"","code":"############################################################ #                      INITIALIZATION ############################################################ # Block matrix structure R <- matrix(c(0.5, -1,               -1, -1), nr = 2) clusters <- list(c(1,3), c(2,4))  # Weight matrix W <- matrix(c(0, 1, 1, 1,               1, 0, 1, 1,               1, 1, 0, 1,               1, 1, 1, 0), nc = 4)  # Random variogram gamma <- matrix(c(0, 2, 1, 0,                   2, 0, 4, 1,                   1, 4, 0, 7,                   0, 1, 7, 0), nc = 4)  # Regularization parameter lambda <- 2.5  ############################################################ #                   NEGATIVE LOG-LIKEHOOD ############################################################ nllh <- neg_likelihood(gamma) nllh(R, clusters) #> [1] 10.72741  ############################################################ #                          PENALTY ############################################################ pen <- penalty(W) pen(R, clusters) #> [1] 18  ############################################################ #             PENALISED NEGATIVE LOG-LIKELIHOOD ############################################################ nllh_pen <- neg_likelihood_pen(gamma, W) nllh_pen(R, clusters, lambda) #> [1] 55.72741"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/merge_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Function which merges clusters — merge_clusters","title":"Function which merges clusters — merge_clusters","text":"Function merges clusters","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/merge_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function which merges clusters — merge_clusters","text":"","code":"merge_clusters(R, clusters, eps_f = 0.1, cost)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/merge_clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function which merges clusters — merge_clusters","text":"R K x K symmetric matrix. clusters list vector : vector gives element cluster. eps_f positive number : minimal tolerance merging clusters cost function : Cost function optimisation","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/merge_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function which merges clusters — merge_clusters","text":"Returns, merging, list new clusters corresponding R matrix, coefficient new clustered computing averaging coefficient two previous clusters.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/merge_clusters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function which merges clusters — merge_clusters","text":"","code":"R <- matrix(c(0.5, -1,               -1, -1), nr = 2) clusters <- list(c(1,3), c(2,4)) W <- matrix(c(0, 1, 1, 1,               1, 0, 1, 1,               1, 1, 0, 1,               1, 1, 1, 0), nc = 4) gamma <- matrix(c(0,2,1,0,                   2,0,4,1,                   1,4,0,7,                   0,1,7,0), nc = 4) cost <- neg_likelihood_pen(gamma, weights, 100000) #> Error in neg_likelihood_pen(gamma, weights, 1e+05): unused argument (1e+05) merge_clusters(R, clusters, cost = cost) #> Error in merge_clusters(R, clusters, cost = cost): could not find function \"merge_clusters\""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/nloglike_grad_np.html","id":null,"dir":"Reference","previous_headings":"","what":"Gradient of the negative log likelihood without penalty — nloglike_grad_np","title":"Gradient of the negative log likelihood without penalty — nloglike_grad_np","text":"Gradient negative log likelihood without penalty","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/nloglike_grad_np.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gradient of the negative log likelihood without penalty — nloglike_grad_np","text":"","code":"nloglike_grad_np(gamma)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/nloglike_grad_np.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gradient of the negative log likelihood without penalty — nloglike_grad_np","text":"gamma d x d variogram matrix.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/nloglike_grad_np.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gradient of the negative log likelihood without penalty — nloglike_grad_np","text":"function R matrix clusters compute gradient matrix negative log likelihood fixed variogram gamma. gradient matrix can computed :   : - dlog = t(U) g(Theta_p) U - 0.5 diag(t(U) g(Theta_p) U) - dtrace = - t(U) gamma U  + 0.5 diag(t(U) gamma U)","code":"dnllh = dlog + dtrace"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/nloglike_grad_np.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gradient of the negative log likelihood without penalty — nloglike_grad_np","text":"","code":"R <- matrix(c(0.5, -1,               -1, -1), nr = 2) clusters <- list(c(1,3), c(2,4)) gamma <- matrix(c(0,2,1,0,                   2,0,4,1,                   1,4,0,7,                   0,1,7,0), nc = 4) gradient <- nloglike_grad_np(gamma) #> Error in nloglike_grad_np(gamma): could not find function \"nloglike_grad_np\" gradient(R, clusters) #> Error in gradient(R, clusters): could not find function \"gradient\""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/penalty_grad.html","id":null,"dir":"Reference","previous_headings":"","what":"Computation of the penalty's gradient — penalty_grad","title":"Computation of the penalty's gradient — penalty_grad","text":"Computation penalty's gradient","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/penalty_grad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computation of the penalty's gradient — penalty_grad","text":"","code":"penalty_grad(weights)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/penalty_grad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computation of the penalty's gradient — penalty_grad","text":"weights d x d symmetric matrix zero diagonal.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/penalty_grad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computation of the penalty's gradient — penalty_grad","text":"function clusters corresponding R matrix. Compute gradient fixed weight. expression gradient just weighted sum gradient tilde D^2 weights clustered weights. See equations section 4.3.3 details.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/penalty_grad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computation of the penalty's gradient — penalty_grad","text":"","code":"R <- matrix(c(0.5, -1,               -1, -1), nr = 2) clusters <- list(c(1,3), c(2,4)) W <- matrix(c(0, 1, 1, 1,               1, 0, 1, 1,               1, 1, 0, 1,               1, 1, 1, 0), nc = 4) dpen <- penalty_grad(W) #> Error in penalty_grad(W): could not find function \"penalty_grad\" dpen(R, clusters) #> Error in dpen(R, clusters): could not find function \"dpen\""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/psolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Moore-Penrose pseudo inverse — psolve","title":"Moore-Penrose pseudo inverse — psolve","text":"Moore-Penrose pseudo inverse","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/psolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Moore-Penrose pseudo inverse — psolve","text":"","code":"psolve(A, tol = 1e-12)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/psolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Moore-Penrose pseudo inverse — psolve","text":"d x d symmetric positive semi-definite matrix.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/psolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Moore-Penrose pseudo inverse — psolve","text":"Computes Moore-Penrose inverse matrix. calculation done thanks article  : = L L^t       (e.g. Crout decomposition) (L zero-columns) : ^+ = L (L^t L)^-1 (L^t L)^-1 L^t","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/psolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Moore-Penrose pseudo inverse — psolve","text":"","code":"A <- matrix(c(1, 2, 3,               2, 5, 6,               3, 6, 9), nc = 3) psolve(A) #> Error in psolve(A): could not find function \"psolve\""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/semi_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-definite checker — semi_def","title":"Semi-definite checker — semi_def","text":"Semi-definite checker","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/semi_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-definite checker — semi_def","text":"","code":"semi_def(M)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/semi_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-definite checker — semi_def","text":"M /eqnn/times n symmetric matrix.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/semi_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-definite checker — semi_def","text":"TRUE matrix semi-definite positive, FALSE otherwise. verification done checking sign eigen-values matrix.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/step_gradient.html","id":null,"dir":"Reference","previous_headings":"","what":"Step for the gradient descent — step_gradient","title":"Step for the gradient descent — step_gradient","text":"Step gradient descent","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/step_gradient.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Step for the gradient descent — step_gradient","text":"","code":"step_gradient(gamma, weights, size_grid = 100)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/step_gradient.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Step for the gradient descent — step_gradient","text":"gamma d x d matrix : variogram matrix. weights d x d symmetric matrix zero diagonal. size_grid integer : size search grid optimal step. lambda positive number : weight penalty.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/step_gradient.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Step for the gradient descent — step_gradient","text":"function clusters R matrix returns next step optimisation gradient descent algorithm.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/step_gradient.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Step for the gradient descent — step_gradient","text":"","code":"R <- matrix(c(0.5, -1,               -1, -1), nr = 2) clusters <- list(c(1, 3), c(2,4)) W <- matrix(c(0, 1, 1, 1,               1, 0, 1, 1,               1, 1, 0, 1,               1, 1, 1, 0), nc = 4) gamma <- matrix(c(0, 2, 1, 0,                   2, 0, 4, 1,                   1, 4, 0, 7,                   0, 1, 7, 0), nc = 4) f <- step_gradient(gamma, W, 0.5) #> Error in step_gradient(gamma, W, 0.5): could not find function \"step_gradient\" f(R, clusters, 1) #> Error in f(R, clusters, 1): could not find function \"f\""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/theta-r.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions to navigate between \\(R\\) and \\(\\Theta\\) for given clusters — theta-r","title":"Functions to navigate between \\(R\\) and \\(\\Theta\\) for given clusters — theta-r","text":"block matrix models defined two elements : cluster's partition \\(\\{C_1, \\dots, C_K\\}\\), included \\(V\\) \\(R\\) matrix belongs \\(\\mathcal S_K(\\mathbb R)\\), set symmetric \\(K \\times K\\) matrix. expression precision \\(\\Theta\\) statisfies block matrix model $$    \\Theta = U R U^t + $$ \\(U\\) cluster matrix \\(\\) diagonal matrix rows theta sum zero : \\( a_{ii} = - \\sum_l p_l r_{kl} \\) \\(\\) cluster \\(C_k\\).","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/theta-r.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions to navigate between \\(R\\) and \\(\\Theta\\) for given clusters — theta-r","text":"","code":"build_theta(R, clusters)  extract_R_matrix(Theta, clusters)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/theta-r.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions to navigate between \\(R\\) and \\(\\Theta\\) for given clusters — theta-r","text":"R build_theta(), \\(K \\times K\\) matrix clusters. clusters list indices associated partition \\(V\\). Theta extract_R_matrix(), \\(d \\times d\\) block matrix can factorizable.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/theta-r.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functions to navigate between \\(R\\) and \\(\\Theta\\) for given clusters — theta-r","text":"extract_R_matrix(), matrix size number clusters (.e. \\(K\\)) corresponding reduced matrix \\(R\\) original matrix \\(\\Theta\\). build_theta(), matrix size number variables (.e. \\(d\\)) corresponding precision matrix \\(\\Theta\\) induced \\(R\\).","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/theta-r.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functions to navigate between \\(R\\) and \\(\\Theta\\) for given clusters — theta-r","text":"","code":"############################################################## #                       FROM THETA TO R ############################################################## Theta <- matrix(  c(4.5, .5, .5, .5, -2, -2, -2,    .5, 4.5, .5, .5, -2, -2, -2,    .5, .5, 4.5, .5, -2, -2, -2,    .5, .5, .5, 4.5, -2, -2, -2,    -2, -2, -2, -2, 6, 1, 1,    -2, -2, -2, -2, 1, 6, 1,    -2, -2, -2, -2, 1, 1, 6),  nc = 7 )  clusters <- list(c(1,2,3,4), c(5,6,7))  extract_R_matrix(Theta, clusters) #>      [,1] [,2] #> [1,]  0.5   -2 #> [2,] -2.0    1  ############################################################## #                       FROM R TO THETA ##############################################################  R <- matrix(c(1, -3, 0,               -3, 2, -2,               0, -2, 1), nc = 3)  clusters <- list(1:4, 5:8, 9:12)  build_theta(R, clusters) #>       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] #>  [1,]    9    1    1    1   -3   -3   -3   -3    0     0     0     0 #>  [2,]    1    9    1    1   -3   -3   -3   -3    0     0     0     0 #>  [3,]    1    1    9    1   -3   -3   -3   -3    0     0     0     0 #>  [4,]    1    1    1    9   -3   -3   -3   -3    0     0     0     0 #>  [5,]   -3   -3   -3   -3   14    2    2    2   -2    -2    -2    -2 #>  [6,]   -3   -3   -3   -3    2   14    2    2   -2    -2    -2    -2 #>  [7,]   -3   -3   -3   -3    2    2   14    2   -2    -2    -2    -2 #>  [8,]   -3   -3   -3   -3    2    2    2   14   -2    -2    -2    -2 #>  [9,]    0    0    0    0   -2   -2   -2   -2    5     1     1     1 #> [10,]    0    0    0    0   -2   -2   -2   -2    1     5     1     1 #> [11,]    0    0    0    0   -2   -2   -2   -2    1     1     5     1 #> [12,]    0    0    0    0   -2   -2   -2   -2    1     1     1     5"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/weight_clustered.html","id":null,"dir":"Reference","previous_headings":"","what":"Computation of the clustered weight matrix — weight_clustered","title":"Computation of the clustered weight matrix — weight_clustered","text":"Computation clustered weight matrix","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/weight_clustered.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computation of the clustered weight matrix — weight_clustered","text":"","code":"weight_clustered(weights)"},{"path":"https://alxkpl.github.io/HRClusterpath/reference/weight_clustered.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computation of the clustered weight matrix — weight_clustered","text":"weights d x d symmetric matrix zero diagonal.","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/weight_clustered.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computation of the clustered weight matrix — weight_clustered","text":"function clusters : weight matrix pair clusters : W_kl = sum_(C_k) sum_(j C_l) w_ij","code":""},{"path":"https://alxkpl.github.io/HRClusterpath/reference/weight_clustered.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computation of the clustered weight matrix — weight_clustered","text":"","code":"clusters <- list(c(1,2,3), c(4,5)) W <- matrix(1:25, nc = 5) W_c <- weight_clustered(W) #> Error in weight_clustered(W): could not find function \"weight_clustered\" W_c(clusters) #> Error in W_c(clusters): could not find function \"W_c\""}]
